(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{446:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一-访问修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-访问修饰符"}},[t._v("#")]),t._v(" 一.访问修饰符")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("修饰符")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("当前类")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("同一包内")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("子孙类(同一包)")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("子孙类(不同包)")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("其他包")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("public")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("protected")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√/×（子类可以）")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("default")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("private")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("√")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("×")])])])]),t._v(" "),a("h2",{attrs:{id:"二-重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-重写"}},[t._v("#")]),t._v(" 二.重写")]),t._v(" "),a("h6",{attrs:{id:"_2-1-方法的重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-方法的重载"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2.1)方法的重载:")])]),t._v(" "),a("p",[t._v("​\t在同一个类中,出现多个同名的方法,参数列表不同,与返回值类型,修饰\t符无关")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("方法名称必须相同。")]),t._v(" "),a("li",[t._v("参数列表必须不同。")]),t._v(" "),a("li",[t._v("方法的返回类型可以相同也可以不相同。")]),t._v(" "),a("li",[t._v("仅仅返回类型不同不足以称为方法的重载")])])]),t._v(" "),a("h6",{attrs:{id:"_2-2-方法的重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-方法的重写"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2.2)方法的重写:")])]),t._v(" "),a("p",[t._v("​\t 子类中出现和父类中一模一样的方法(包括返回值类型,方法名,参数列表)")]),t._v(" "),a("h6",{attrs:{id:"_2-3-方法重写的注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-方法重写的注意事项"}},[t._v("#")]),t._v(" 2.3)"),a("strong",[t._v("方法重写的注意事项:")])]),t._v(" "),a("p",[t._v("1.重写的方法必须要和父类一模一样(包括返回值类型,方法名,参数列表)")]),t._v(" "),a("p",[t._v("2.重写的方法可以使用@Override注解来标识")]),t._v(" "),a("p",[t._v("3."),a("strong",[t._v("子类中重写的方法的访问权限不能低于父类中方法的访问权限")])]),t._v(" "),a("p",[a("strong",[t._v("权限修饰符 : private <  默认(什么都不写) <  protected < public")])]),t._v(" "),a("h6",{attrs:{id:"_2-4-为什么要重写方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-为什么要重写方法"}},[t._v("#")]),t._v(" 2.4)为什么要重写方法:")]),t._v(" "),a("p",[t._v("1.当父类中的方法无法满足子类需求的时候,需要方法重写")]),t._v(" "),a("p",[t._v("2.当子类具有特有的功能的时候,就需要方法重写")]),t._v(" "),a("h6",{attrs:{id:"_2-5-重写的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-重写的应用"}},[t._v("#")]),t._v(" 2.5)重写的应用")]),t._v(" "),a("p",[t._v("子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。")]),t._v(" "),a("h2",{attrs:{id:"三-抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-抽象类"}},[t._v("#")]),t._v(" 三.抽象类")]),t._v(" "),a("h3",{attrs:{id:"_1、概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、概述"}},[t._v("#")]),t._v(" 1、概述")]),t._v(" "),a("p",[t._v("当父类知道子类应该包含什么样的方法，但无法确定子类如何实现这些方法；在分析事物时，会发现事物的共性，将共性抽取出，实现的时候，就会有这样的情况：方法功能声明相同，但方法功能主体不同，这时，将方法声明抽取出，那么，此方法就是一个抽象方法。")]),t._v(" "),a("h6",{attrs:{id:"_1、抽象的定义格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、抽象的定义格式"}},[t._v("#")]),t._v(" "),a("strong",[t._v("1、抽象的定义格式")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("抽象方法的定义格式：public abstract 返回值类型 方法名（参数）；")]),t._v(" "),a("li",[t._v("抽象类的定义格式：abstract class 类名{}")])])]),t._v(" "),a("h6",{attrs:{id:"_2、抽象的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、抽象的特点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2、抽象的特点")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("抽象类和抽象方法都需要被 abstract 修饰，抽象方法一定要定义在抽象类中")]),t._v(" "),a("li",[t._v("抽象不能直接创建对象，因为调用抽象方法没有意义")]),t._v(" "),a("li",[t._v("只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象，否则该子类还是一个抽象类")]),t._v(" "),a("li",[t._v("之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单")])])]),t._v(" "),a("h6",{attrs:{id:"_3、抽象类的注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、抽象类的注意事项"}},[t._v("#")]),t._v(" "),a("strong",[t._v("3、抽象类的注意事项")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("抽象类一定是个父类，因为是不断抽取而来的")]),t._v(" "),a("li",[t._v("抽象类中可以不定义抽象方法，其存在的意义就是不让该类创建对象，方法可以直接让子类去使用")]),t._v(" "),a("li",[t._v("抽象关键字 abstract 不可以和以下关键字共存：\nprivate：私有的方法子类是无法继承到的，也不存在覆盖，如果 abstract 和 private 一起使用修饰方法， abstract 既要子类去实现这个方法，而 private 修饰子类根本无法得到父类这个方法，互相矛盾\nfinal：final 修饰的类不能被继承，而抽象类一定是父类\nstatic：static 修饰的表示静态的，不能被修改的，但可以直接被类所调用，而abstract修饰的是抽象的，即没有方法实体，也不能直接被调用")])])]),t._v(" "),a("h3",{attrs:{id:"_2、代码实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、代码实例"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2、代码实例")])]),t._v(" "),a("h6",{attrs:{id:"_1-先创建develop-java父类-创建develop抽象类-并创建抽象方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-先创建develop-java父类-创建develop抽象类-并创建抽象方法"}},[t._v("#")]),t._v(" 1.先创建Develop.java父类，创建Develop抽象类，并创建抽象方法")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyAbstract")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 定义开发人员类，所有开发人员都具有工作的共性，\n * 对工作共性进行抽取，然后形成一个Develop类\n * 定义方法：工作\n * 抽象类不能实例化对象，即不能new，抽象方法没有主体，不能运行\n * 抽象类的使用：可以定义类继承抽象类，将抽象方法进行重写，创建子类的对象\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Develop")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//定义工作方法，但具体怎么工作，并不明白，所以干脆不说，即抽象方法")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//必须使用abstract关键字修饰")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//抽象的方法必须存在抽象类中，类也必须使用abstract关键字修饰")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("work")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h6",{attrs:{id:"_2-再创建php-java子类-重写父类的抽象方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-再创建php-java子类-重写父类的抽象方法"}},[t._v("#")]),t._v(" 2.再创建Php.java子类，重写父类的抽象方法")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyAbstract")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 定义PHP开发人员\n * 继承抽象类Develop，重写抽象的方法\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Php")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Develop")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重写父类的抽象方法，去掉abstract关键字，加上方法主体")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("work")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"正在开发网页！"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h6",{attrs:{id:"_3-在main-java中调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-在main-java中调用"}},[t._v("#")]),t._v(" 3.在Main.java中调用")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyAbstract")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Main")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Php")]),t._v(" ph "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Php")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        ph"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("work")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h6",{attrs:{id:"实例解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例解析"}},[t._v("#")]),t._v(" 实例解析=>")]),t._v(" "),a("ul",[a("li",[t._v("将共性“研发人员”抽取出来形成一个Develop类并定义方法：工作")]),t._v(" "),a("li",[t._v("抽象类不能实例化，即不能 new 抽象方法没有主体")]),t._v(" "),a("li",[t._v("可以定义类来继承抽象类，将抽象类进行重写，然后创建子类的对象")]),t._v(" "),a("li",[t._v("重写父类的抽象方法时，去掉abstract关键字，加上方法主体")])]),t._v(" "),a("h2",{attrs:{id:"四-final修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-final修饰符"}},[t._v("#")]),t._v(" 四.final修饰符")]),t._v(" "),a("p",[t._v("​\t1.修饰的类,不能在被继承")]),t._v(" "),a("p",[t._v("​\t2.修饰的方法不能被子类重写")]),t._v(" "),a("p",[t._v("​\t3.修饰的变量将变成厂里,只能在初始化时进行赋值")])])}),[],!1,null,null,null);a.default=n.exports}}]);